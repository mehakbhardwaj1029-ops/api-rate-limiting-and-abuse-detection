When will the token bucket fail?

1. Concurrent Requests
If 2 requests arriving at the same millisecond and bucket has 1 token, then it will break the rate limiting.

Thread A reads tokens = 1
Thread B reads tokens = 1

Thread A consumes token → tokens = 0
Thread B consumes token → tokens = 0

Both requests are allowed 

2. Race during refill-

If bucket is empty after consuming all the requests but then after some time multiple requests hit together.

Then each thread will calculate refill and add tokens independently which will overwhelm the bucket and tokens might exceed bucket's capacity.

3. Distributed deployment -

More than 1 instances of your service are running independently while accessing the same redis.
Each instance will make the changes independently which leads to inconsistency in data.

4. Latency Issues -

* network latency 
* cpu scheduling
* thread context switching
can lead to increase in delay and race conditions.

Atomicity in Redis:
Since redis is single threaded internally , so it executes one command at a time before fully moving to the next command.

So ,lets say 2 servers get a request but the bucket has 1 token left then:

A: GET tokens → 1
B: GET tokens → 1

A: SET tokens → 0
B: SET tokens → 0

Independently A and B assume that nothing is wrong but in reality 1 token served 2 request which will break redis

How Redis Lua Manages it:

A Lua is a script in redis which can execute multiple operations as 1 command.

Lua script starts
GET
COMPUTE
SET
Lua script ends

Basically a request is getting locked before it completely executed.

So,
No other commands can run in between.
No other client interferes.
No race condition.

This is like synchronization but i have'nt gone for synchronization because:

Synchronization can manage concurrent request only if you have monolithic system and 1 JVM running 

but in distributed processing various JVM's, processors are involved there JAVA based synchronization will fail.

So,

Scenario                      Java Lock	                Redis Lua

Single-thread	              Not needed	            Not needed

Multi-thread, single JVM	     Works	                Optional

Distributed (multiple JVMs)	     Fails              	Required